C51 COMPILER V6.02  MAIN                                                                   05/05/2017 16:46:38 PAGE 1   


C51 COMPILER V6.02, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\main.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE .\main.c DEBUG OBJECTEXTEND

stmt level    source

   1          #include <reg932.h>
   2          #include "uart.h" //Needed for serial communications
   3          #include "main_music.h"
   4          
   5          //Button definitions
   6          sbit bTopLeft = P2^0;
   7          sbit bTopMid = P0^1;
   8          sbit bTopRight = P2^3;
   9          sbit bMidLeft = P0^2;
  10          sbit bMidMid = P1^4;
  11          sbit bMidRight = P0^0;
  12          sbit bBotLeft = P2^1;
  13          sbit bBotMid = P0^3;
  14          sbit bBotRight = P2^2;
  15          
  16          //Description: The display() outputs the current state of the game
  17          //to the serial port.
  18          //Pre:  gameStatus[] must be populated or cleared
  19          //Post: Current state of the game will be displayed.
  20          
  21          //Light definitions
  22          sbit lTopLeft = P2^4;
  23          sbit lTopMid = P0^5;
  24          sbit lTopRight = P2^7;
  25          sbit lMidLeft = P0^6;
  26          sbit lMidMid = P1^6;
  27          sbit lMidRight = P0^4;
  28          sbit lBotLeft = P2^5;
  29          sbit lBotMid = P0^7;
  30          sbit lBotRight = P2^6;
  31          
  32          //Jonathan Gassner's pins for score counters
  33          sbit p1_pulse = P1^2;
  34          sbit p2_pulse = P1^3;
  35          unsigned char pulse_counter;
  36          
  37          
  38          #define LED_FLASH_TIME_HIGH -65535 >> 8
  39          #define LED_FLASH_TIME_LOW  -65535
  40          
  41          unsigned char length;
  42          
  43          void restart_timer1 ( );
  44          void SerialDisplay(char *);
  45          //Handles 1-time initialization code
  46          void StartGame();
  47          char PollButtons();
  48          void play_sound_byte();
  49          bit CheckWin();
  50          
  51          
  52          
  53          // --------------------
  54          // Connors variables end
  55          // --------------------
C51 COMPILER V6.02  MAIN                                                                   05/05/2017 16:46:38 PAGE 2   

  56          
  57          
  58          
  59          
  60          //Characters representing each location's status
  61          // ' ' means Not taken
  62          // 'O' means taken by O
  63          // 'X' means taken by X
  64          
  65          //First 3 characters are top row left->right
  66          //Next 3 are middle row left->right
  67          //Last 3 are bottom row left->right
  68          char gameStatus[10];
  69          
  70          //Boolean variable to track if the game should continue
  71          bit gameEnd;
  72          
  73          // boolean to determine if introduction music is done
  74          bit introduction_flag;
  75          
  76          
  77          
  78          //Loops through and checks each button
  79          //Returns (as a number) the location of the first
  80          //button pressed
  81          // 0 is returned if no button is pressed
  82          
  83          //Location grid layout
  84          
  85          //------Top------//
  86          // 1  |  2  |  3 //
  87          // 4  |  5  |  6 //
  88          // 7  |  8  |  9 //
  89          //-----Bottom----//
  90          
  91          char msg_i = 0;
  92          
  93          
  94          unsigned char input = 0x00;//The input from a specific polling sequence
  95          
  96          
  97          char welcome_msg[] = "HELLO!\n\0";
  98          
  99          
 100          
 101          int iterator = 0;
 102          
 103          char current_player = 'X';
 104          
 105          
 106          
 107          char game_output[] = " | | "; // used in printGameStatus
 108          char line[] = "-----";       // used in printGameStatus
 109          char row;                     // used in printGameStatus
 110          char col;                    // used in printGameStatus
 111          
 112          bit AI_flag = 1;
 113          
 114          
 115          
 116          
 117          
C51 COMPILER V6.02  MAIN                                                                   05/05/2017 16:46:38 PAGE 3   

 118          
 119          
 120          
 121          
 122          
 123          
 124          
 125          
 126          // ----------------------------
 127          // Connor's variables start
 128          // ----------------------------
 129          
 130          //-----------------------
 131          
 132          //start									1		2			3			4		5			6		7		8			9			10		11			12			13		14		15			16			17***lastone		18			19		   
             -20		21			22			23			24		25			26			27		28			29			30			31		32			33
 133          unsigned char song_main_buzzer1[]   = {NOTE_REST, NOTE_A6, NOTE_REST, NOTE_A6, NOTE_REST, NOTE_G6, NOTE_RE
             -ST, NOTE_G6, NOTE_REST, NOTE_A6,   NOTE_REST, NOTE_A6, NOTE_C7,   NOTE_REST, NOTE_A6, NOTE_REST, NOTE_REST, NOTE_G6,  NO
             -TE_REST, NOTE_A5,  NOTE_REST, NOTE_F5,  NOTE_REST, NOTE_D5,    NOTE_F5   ,NOTE_REST, NOTE_G5,  NOTE_REST, NOTE_F5,    NO
             -TE_REST, NOTE_REST, NOTE_F5,  NOTE_REST, NOTE_REST };
 134          //unsigned char song_main_buzzer2[] = {NOTE_E4, NOTE_REST, NOTE_E4, NOTE_REST, NOTE_E4, NOTE_REST, NOTE_E4
             -, NOTE_REST, NOTE_E4,   NOTE_REST, NOTE_E4, NOTE_G4,   NOTE_REST, NOTE_E4, NOTE_REST, NOTE_REST, NOTE_D4,  NOTE_REST, NO
             -TE_D4,  NOTE_REST, NOTE_D4,  NOTE_REST, NOTE_AS3,   NOTE_REST };
 135          //unsigned char song_main_buzzer3[] = {NOTE_C4, NOTE_REST, NOTE_C4, NOTE_REST, NOTE_G4, NOTE_REST, NOTE_C4
             -, NOTE_REST, NOTE_C4,   NOTE_REST, NOTE_C4, NOTE_E4,   NOTE_REST, NOTE_C4, NOTE_G4,   NOTE_REST, NOTE_AS3, NOTE_REST, NO
             -TE_AS3, NOTE_REST, NOTE_AS3, NOTE_REST, NOTE_REST,  NOTE_REST };
 136          //unsigned char song_main_buzzer4[] = {NOTE_C3, NOTE_REST, NOTE_A2, NOTE_REST, NOTE_G2, NOTE_REST, NOTE_A2
             -, NOTE_C3,   NOTE_REST, NOTE_C3,   NOTE_A2, NOTE_REST, NOTE_C3,   NOTE_G2, NOTE_A2,   NOTE_F4,   NOTE_AS2, NOTE_REST, NO
             -TE_G2,  NOTE_REST, NOTE_F2,  NOTE_REST, NOTE_G2,    NOTE_AS2  };
 137          //unsigned char song_main_duration[]= {DUR_8, DUR_8, DUR_8,   DUR_8,     DUR_8,   DUR_8,     DUR_8,   DUR_
             -8,     DUR_8,   DUR_8,     DUR_8,     DUR_8,     DUR_8,   DUR_8,     DUR_8,     DUR_8,   DUR_8,     DUR_8,     DUR_8,   
             - DUR_8,     DUR_8,    DUR_8,     DUR_8,    DUR_8,     DUR_8,      DUR_8     ,DUR_8,     DUR_8,    DUR_8,     DUR_8,     
             - DUR_8,     DUR_8,     DUR_8,    DUR_8,     DUR_8     };
 138          //unsigned char song_main_duration[] = {DUR_8};
 139          // first ending
 140          //unsigned char song_ending1_buzzer1[] = {NOTE_REST, NOTE_G4,  NOTE_REST, NOTE_F4,    NOTE_REST, NOTE_REST
             -, NOTE_F4,  NOTE_REST, NOTE_REST };
 141          //unsigned char song_ending1_buzzer2[] = {NOTE_REST, NOTE_D4,  NOTE_REST, NOTE_D4,    NOTE_REST, NOTE_REST
             -, NOTE_D4,  NOTE_REST, NOTE_REST };
 142          //unsigned char song_ending1_buzzer3[] = {NOTE_REST, NOTE_AS3, NOTE_REST, NOTE_AS3,   NOTE_REST, NOTE_G4, 
             -  NOTE_AS3, NOTE_REST, NOTE_REST };
 143          //unsigned char song_ending1_buzzer4[] = {NOTE_REST, NOTE_AS2, NOTE_G2,   NOTE_REST,  NOTE_F2,   NOTE_F2, 
             -  NOTE_G2,  NOTE_F2,   NOTE_REST };
 144          //unsigned char song_ending1_duration[]= {DUR_8,     DUR_8,    DUR_8,     DUR_8,      DUR_8,     DUR_8,   
             -  DUR_8,    DUR_8,     DUR_8     };
 145          
 146          
 147          
 148          sbit SPKR = P1^7;            // port used for speaker
 149          
 150          // Temporary variables
 151          sbit led1 = P2^4;
 152          sbit led2 = P0^5;
 153          
 154          unsigned char note_MCs;
 155          unsigned char note_its;
 156          unsigned char duration;
 157          
 158          
 159          unsigned char nbc_notes[] =     {NOTE_G5, NOTE_E5, NOTE_C4};
 160          unsigned char nbc_durations[] = {32, 32, 64};
 161          
C51 COMPILER V6.02  MAIN                                                                   05/05/2017 16:46:38 PAGE 4   

 162          unsigned char note_num = 0;
 163          unsigned char num_notes = 32;//23; //24 for main_buzzer
 164          
 165          
 166          // note_ptr points to the array containing the number n that corresponds to
 167          // 111*n = number of machine cycles per oscillation for a given note
 168          char idata *note_ptr;
 169          
 170          // duration_ptr points to the array containing the number n that corresponds to
 171          // (n / 32)th note when using a given tempo
 172          char idata *duration_ptr;
 173          
 174          char mod;
 175          char rest_played;
 176          
 177          bit introduction_flag = 1;
 178          bit nbc_flag = 0;
 179          
 180          
 181          void shortDelay()
 182          {
 183   1        for (pulse_counter = 0; pulse_counter < 255; pulse_counter++);
 184   1      }
 185          
 186          void play_sound_byte ( )
 187          {
 188   1        // set the music to be the NBC clip
 189   1        //note_ptr =     nbc_notes;
 190   1        //duration_ptr = nbc_durations;
 191   1      
 192   1        // ------------------------------------------------------
 193   1        // set up the timers
 194   1        // ------------------------------------------------------
 195   1      
 196   1        // Timer 0 ==> 8-bit auto-reload
 197   1        // Timer 1 ==> 16-bit mode
 198   1        TMOD = 0x12;
 199   1      
 200   1        // Enable Timer 0, Timer 1 interrupts
 201   1        // Disable Serial interrupts
 202   1        IEN0 |= 0x8A;
 203   1      
 204   1        // Prioritize Timer 1 over Timer 0
 205   1        IP0 = 0x08;
 206   1      
 207   1        // Timer 0 will raise a flag based on the note frequency
 208   1        TH0 = FREQUENCY_DIVISOR;
 209   1        TL0 = FREQUENCY_DIVISOR;
 210   1      
 211   1        // Timer 1 will raise a flag every time the duration of a 32nd note is played
 212   1        TH1 = DURATION_32_NOTE >> 8;
 213   1        TL1 = DURATION_32_NOTE;
 214   1      
 215   1        mod = 1;
 216   1        rest_played = 0;
 217   1      
 218   1        duration = 0;  // set for 8 32nd notes
 219   1        note_its = 0;  // reset of count of iterations (to 111)
 220   1      
 221   1      
 222   1        TF1 = 1; // start timer 1
 223   1      
C51 COMPILER V6.02  MAIN                                                                   05/05/2017 16:46:38 PAGE 5   

 224   1        /*if (note_ptr != 1)
 225   1        {
 226   1          TR0 = 1;
 227   1        }*/
 228   1      
 229   1        SPKR = 0;
 230   1        while(introduction_flag);
 231   1      }
 232          
 233          
 234          
 235          
 236          
 237          // The Timer1 ISR is responsible for providing the duration
 238          // of the note being played
 239          
 240          void timer1_isr ( ) interrupt TIMER_1
 241          {
 242   1        // turn off the timer while working
 243   1        TR1 = 0;
 244   1      
 245   1        // if we have not yet reached the note's full duration
 246   1        length = DUR_8;
 247   1        if ( nbc_flag )
 248   1        {
 249   2          length = duration_ptr[note_num];
 250   2        }
 251   1        
 252   1        if ( duration != length )
 253   1        {    
 254   2          // if we are using half time
 255   2          if (HALF_TIME_BOOL)
 256   2          {
 257   3            // every other trigger, we increment duration
 258   3            mod = (++mod) % 10;
 259   3            if ( mod != 9 )
 260   3            {
 261   4              duration++;
 262   4            }
 263   3          }
 264   2          // otherwise
 265   2          else
 266   2          {
 267   3            // always increment duration
 268   3            duration++;
 269   3          }
 270   2      
 271   2      	restart_timer1();
 272   2        }
 273   1      
 274   1        // if we have reached the note's full duration
 275   1         else
 276   1        {
 277   2          // stop playing the current note
 278   2          TR0 = 0;
 279   2          TF0 = 0;
 280   2      	note_its = 0;
 281   2          SPKR = 0;
 282   2      
 283   2          // make sure we have rested adequately
 284   2          if ( rest_played != 5 )
 285   2          {
C51 COMPILER V6.02  MAIN                                                                   05/05/2017 16:46:38 PAGE 6   

 286   3            // acknowledge that this code has been executed
 287   3            rest_played++;
 288   3      
 289   3            // wait the smallest possible note length
 290   3            restart_timer1();
 291   3            return;
 292   3          }
 293   2      
 294   2          //no matter what
 295   2          
 296   2          // reset the duration
 297   2          duration = 0;
 298   2      
 299   2          // reset the mod, so we don't get left out if in half time
 300   2          mod = 1;
 301   2       
 302   2          // if we are at the last note, we light the LED
 303   2          if ( note_num == num_notes )
 304   2          {
 305   3            introduction_flag = 0;
 306   3            note_ptr = nbc_notes;
 307   3            duration_ptr = nbc_durations;
 308   3            num_notes = 3;
 309   3            note_num = 0;
 310   3          }
 311   2      
 312   2          // otherwise, if there are still notes in the song
 313   2          else
 314   2          {
 315   3            // move on to the next note
 316   3            note_num++;
 317   3      
 318   3            // if the note is stored as 0, do not worry about oscillating
 319   3            // b/c it is a rest!
 320   3            if ( note_ptr[note_num] == 0 )
 321   3            {
 322   4              // turn off timer 0
 323   4              TR0 = 0;
 324   4            }
 325   3      
 326   3            // otherwise, the note is real... we must worry
 327   3            else
 328   3            {
 329   4              // set the frequency of the note by pushing to TH0
 330   4              // turn on the timer 0;
 331   4              TH0 = note_ptr[note_num];
 332   4              TL0 = TH0;
 333   4              TR0 = 1;
 334   4            }
 335   3      
 336   3            // ensure that since there are more notes, we are still timing their
 337   3            // durations
 338   3            TR1 = 1;
 339   3      
 340   3            // notice that the rest for the other note has not yet been played
 341   3            // so we must reset this variable
 342   3            rest_played = 0;
 343   3          }
 344   2        }
 345   1      }
 346          
 347          
C51 COMPILER V6.02  MAIN                                                                   05/05/2017 16:46:38 PAGE 7   

 348          void restart_timer1 ( )
 349          {
 350   1        TH1 = DURATION_32_NOTE >> 8;
 351   1        TL1 = DURATION_32_NOTE;
 352   1        TR1 = 1;
 353   1      }
 354          
 355          
 356          /*
 357            timer 0 interrupt service routine
 358            when introduction_flag == 0:
 359              ...
 360            when introduction_flag == 1:
 361          */
 362          void display ( ) interrupt TIMER_0
 363          {
 364   1      
 365   1        if (introduction_flag)
 366   1        {
 367   2           /*
 368   2           This function oscillates the speaker when the flag is raised
 369   2           the FREQUENCY_DIVISOR times. Since the flag is based on the timer
 370   2           which triggers based on what the current note is, we can vary the
 371   2           pitch by changing the timer amount. When we oscillate the speaker,
 372   2           we also reset note_its so it can start counting again.
 373   2          */
 374   2      
 375   2          // if triggered FREQUENCY_DIVISOR times
 376   2          if (note_its == note_ptr[note_num])
 377   2          {
 378   3            // oscillate speaker and reset count
 379   3            SPKR = ~SPKR;
 380   3            note_its = 0;
 381   3          }
 382   2      
 383   2          // otherwise, mark it and wait until reflagged
 384   2          else
 385   2          {
 386   3            note_its++;
 387   3          }
 388   2        }
 389   1        else
 390   1        {
 391   2          TR0 = 0;
 392   2          if(gameStatus[0] == 'X')
 393   2      	  lTopLeft = 0;
 394   2      	else if(gameStatus[0] == 'O')
 395   2      	  lTopLeft = ~lTopLeft;
 396   2      	if(gameStatus[1] == 'X')
 397   2      	  lTopMid = 0;
 398   2      	else if(gameStatus[1] == 'O')
 399   2      	  lTopMid = ~lTopMid;
 400   2      	if(gameStatus[2] == 'X')
 401   2      	  lTopRight = 0;
 402   2      	else if(gameStatus[2] == 'O')
 403   2      	  lTopRight = ~lTopRight;
 404   2      	if(gameStatus[3] == 'X')
 405   2      	  lMidLeft = 0;
 406   2          else if(gameStatus[3] == 'O')
 407   2      	  lMidLeft = ~lMidLeft;
 408   2      	if(gameStatus[4] == 'X')
 409   2      	  lMidMid = 0;
C51 COMPILER V6.02  MAIN                                                                   05/05/2017 16:46:38 PAGE 8   

 410   2      	else if(gameStatus[4] == 'O')
 411   2      	  lMidMid = ~lMidMid;
 412   2      	if(gameStatus[5] == 'X')
 413   2      	  lMidRight = 0;
 414   2      	else if(gameStatus[5] == 'O')
 415   2      	  lMidRight = ~lMidRight;
 416   2      	if(gameStatus[6] == 'X')
 417   2      	  lBotLeft = 0;
 418   2      	else if(gameStatus[6] == 'O')
 419   2      	  lBotLeft = ~lBotLeft;
 420   2      	if(gameStatus[7] == 'X')
 421   2      	  lBotMid = 0;
 422   2      	else if(gameStatus[7] == 'O')
 423   2      	  lBotMid = ~lBotMid;
 424   2      	if(gameStatus[8] == 'X')
 425   2      	  lBotRight = 0;
 426   2      	else if(gameStatus[8] == 'O')
 427   2      	  lBotRight = ~lBotRight;
 428   2      	TH0= LED_FLASH_TIME_HIGH;
 429   2      	TL0 = LED_FLASH_TIME_LOW;
 430   2      	TR0 = 1;
 431   2        }
 432   1        return;
 433   1      }
 434          
 435          
 436          // ------------------------------------
 437          // print Game Status
 438          // ------------------------------------
 439          void printGameStatus ( )
 440          {
 441   1      
 442   1        for (row = 0; row < 3; row++)
 443   1        {	  
 444   2          for (col = 0; col < 3; col++)
 445   2          {
 446   3            game_output[col * 2] = gameStatus[3 * row + col];
 447   3          }
 448   2          SerialDisplay(game_output);
 449   2          
 450   2          if (row != 2)
 451   2            SerialDisplay(line);
 452   2        }
 453   1      
 454   1        uart_transmit('\n');
 455   1        //led1 = 1;
 456   1      }
 457          
 458          char ai_input ( )
 459          {
 460   1        for (iterator = 0; iterator < 9; iterator++)
 461   1        {
 462   2          if (gameStatus[iterator] == ' ')
 463   2          {
 464   3            return (char) iterator + 1;
 465   3          }
 466   2        }
 467   1        return 0;
 468   1      }
 469          
 470          
 471          void main ( )
C51 COMPILER V6.02  MAIN                                                                   05/05/2017 16:46:38 PAGE 9   

 472          { 
 473   1        P2M1 = 0x00;
 474   1        P1M1 = 0x00;
 475   1        P0M1 = 0x00;
 476   1        gameStatus[9] = 0; //null terminating char array
 477   1        //introduction_flag = 1;
 478   1        note_ptr =     nbc_notes;//song_main_buzzer1;
 479   1        duration_ptr = nbc_durations;
 480   1        num_notes = 2;
 481   1        //play_sound_byte();
 482   1        introduction_flag = 0;
 483   1        
 484   1        //char input = 0; 
 485   1        EA = 1;  //Enalbes interrupts
 486   1      
 487   1        //Setup I/O ports
 488   1        //TODO - Using bidirectional for now, does serial need something else?
 489   1        uart_init(); //Initializes serial transmission
 490   1        SerialDisplay(welcome_msg);  //Just for testings
 491   1      
 492   1        
 493   1        //Loop forever until power off
 494   1        while(1)
 495   1        {
 496   2          StartGame();
 497   2      
 498   2      
 499   2      	//Game loop - run until victory
 500   2      	while(!gameEnd)
 501   2          {
 502   3      
 503   3            //Check for input
 504   3      	  do
 505   3      	  {
 506   4              if (AI_flag && current_player == 'O')
 507   4              {
 508   5                input = ai_input();
 509   5              }
 510   4              else
 511   4              {
 512   5                input = PollButtons();
 513   5              }
 514   4      	  }
 515   3            while(input == 0 || gameStatus[input - 1] != ' ');
 516   3            
 517   3            //Record new game input
 518   3            gameStatus[input - 1] = current_player;
 519   3      
 520   3            printGameStatus();
 521   3      
 522   3            //Check for win condition
 523   3            if(CheckWin())
 524   3      	  {
 525   4      	    //Victory
 526   4              gameEnd = 1;
 527   4              //This is for Jonathan's individual part.
 528   4      
 529   4              if (current_player == 'X')  
 530   4              {
 531   5                  p1_pulse = 1;
 532   5                  shortDelay();
 533   5                  p1_pulse = 0;
C51 COMPILER V6.02  MAIN                                                                   05/05/2017 16:46:38 PAGE 10  

 534   5              }
 535   4              else
 536   4              {  
 537   5                  p2_pulse = 1;
 538   5                  shortDelay();
 539   5                  p2_pulse = 0;
 540   5              }
 541   4                
 542   4        	  }
 543   3      
 544   3            // switches players
 545   3      	  if (current_player == 'X')
 546   3            {
 547   4              current_player = 'O';
 548   4            }
 549   3            else
 550   3            {
 551   4              current_player = 'X';
 552   4            }
 553   3      	  //Wait for buttons to release
 554   3      	  while(PollButtons() != 0);
 555   3          }
 556   2          // Game is now over!! Play NBC
 557   2          introduction_flag = 1;
 558   2          play_sound_byte();
 559   2          
 560   2        }
 561   1      }
 562          
 563          
 564          
 565          
 566          void StartGame(){
 567   1        char i;
 568   1        gameEnd = 0;
 569   1        
 570   1        for(i = 0; i < 9; i++){
 571   2          gameStatus[i] = ' ';
 572   2        }
 573   1      
 574   1        //Reset lights
 575   1        lTopLeft = 1;
 576   1        lTopMid = 1;
 577   1        lTopRight = 1;
 578   1        lMidLeft = 1;
 579   1        lMidMid = 1;
 580   1        lMidRight = 1;
 581   1        lBotLeft = 1;
 582   1        lBotMid = 1;
 583   1        lBotRight = 1;
 584   1      
 585   1        //Initialize timer 0 for LED calculations
 586   1        TMOD = 0x01;
 587   1        TH0 = LED_FLASH_TIME_HIGH;
 588   1        TL0 = LED_FLASH_TIME_LOW;
 589   1        IEN0 |= 0x82;
 590   1        TR0 = 1;
 591   1      
 592   1        //Player 1 should always go first
 593   1        current_player = 'X';
 594   1      
 595   1        return;
C51 COMPILER V6.02  MAIN                                                                   05/05/2017 16:46:38 PAGE 11  

 596   1      }
 597          
 598          char PollButtons(){
 599   1        //Loop through and check each button
 600   1        if(!bTopLeft)
 601   1          return 1;
 602   1        if(!bTopMid)
 603   1          return 2;
 604   1        if(!bTopRight)
 605   1          return 3;
 606   1        if(!bMidLeft)
 607   1          return 4;
 608   1        if(!bMidMid)
 609   1          return 5;
 610   1        if(!bMidRight)
 611   1          return 6;
 612   1        if(!bBotLeft)
 613   1          return 7;
 614   1        if(!bBotMid)
 615   1          return 8;
 616   1        if(!bBotRight)
 617   1          return 9;
 618   1      
 619   1        return 0;
 620   1      }
 621          
 622          bit CheckWin(){
 623   1        //Check winning by rows
 624   1        int i = 0;
 625   1        for(i = 0; i < 3; i++)
 626   1        {
 627   2          if(gameStatus[3 * i] == gameStatus[(3*i) + 1] &&
 628   2      	   gameStatus[3 * i] == gameStatus[(3*i) + 2] &&
 629   2      	   gameStatus[3 * i] != ' ')
 630   2      	   
 631   2      	   return 1;
 632   2        }
 633   1      
 634   1        //Check winning by columns
 635   1        for(i = 0; i < 3; i++)
 636   1        {
 637   2          if(gameStatus[i] == gameStatus[i + 3] &&
 638   2      	   gameStatus[i] == gameStatus[i + 6] &&
 639   2      	   gameStatus[i] != ' ')
 640   2      	   
 641   2      	   return 1;
 642   2        }
 643   1      
 644   1        //Check diagonals
 645   1        if(gameStatus[0] == gameStatus[4] &&
 646   1           gameStatus[0] == gameStatus[8] &&
 647   1      	 gameStatus[0] != ' ')
 648   1      	 
 649   1      	 return 1;
 650   1      
 651   1        if(gameStatus[2] == gameStatus[4] &&
 652   1           gameStatus[2] == gameStatus[6] &&
 653   1      	 gameStatus[2] != ' ')
 654   1      
 655   1      	 return 1;
 656   1      
 657   1      
C51 COMPILER V6.02  MAIN                                                                   05/05/2017 16:46:38 PAGE 12  

 658   1         return 0;
 659   1      }
 660          
 661          void SerialDisplay(char s_msg[])
 662          {
 663   1        msg_i = 0;
 664   1        while (s_msg[msg_i] != '\0')
 665   1        {
 666   2          uart_transmit(s_msg[msg_i]);
 667   2          msg_i++;
 668   2        }
 669   1      
 670   1        for(iterator = 0; iterator < 10000; iterator++);
 671   1        return;
 672   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    984    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     89       3
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      4    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
